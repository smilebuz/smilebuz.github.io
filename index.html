<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="想做个盖世英雄">
<meta property="og:type" content="website">
<meta property="og:title" content="XPZ">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="XPZ">
<meta property="og:description" content="想做个盖世英雄">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XPZ">
<meta name="twitter:description" content="想做个盖世英雄">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> XPZ </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XPZ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我是个小胖子</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/29/js中的浅拷贝与深拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="victorxpz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/chai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XPZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/29/js中的浅拷贝与深拷贝/" itemprop="url">
                  js中的浅拷贝与深拷贝
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-29T11:46:43+08:00">
                2017-08-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在项目中对数组使用了扩展运算(spread)进行了拷贝，但是发现修改拷贝后数组中对元素，同样会对原数组进行更改。查阅资料后发现，通过扩展运算进行的拷贝是浅拷贝，也就是说对于原数组中的引用类型元素拷贝的还是其引用，而不是完全创建一个新的元素。因为之前没有仔细了解过浅拷贝与深拷贝的概念，所以学习了一下，在这里写一下自己的理解。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>首先要理解的一点是，在js中浅拷贝和深拷贝都是针对对象、数组这样的引用类型的变量而言，对于基本类型的变量是不讨论浅拷贝与深拷贝的。</p>
<p>浅拷贝拷贝的是原对象的引用，因此对于拷贝后对象的改变也会映射到原对象中，最常见的浅拷贝方法就是直接用<code>=</code>进行赋值操作，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 数组</div><div class="line">let arr1 = [1, 2, 3]</div><div class="line">let arr2 = arr1</div><div class="line"></div><div class="line">arr2[0] = 4</div><div class="line"></div><div class="line">// arr1 [4, 2, 3]</div><div class="line">// arr2 [4, 2, 3]</div><div class="line"></div><div class="line">// 对象</div><div class="line">let obj1 = &#123;a: 1&#125;</div><div class="line">let obj2 = obj1</div><div class="line"></div><div class="line">obj1.a = 2</div><div class="line"></div><div class="line">// obj1 &#123;a: 2&#125;</div><div class="line">// obj2 &#123;a: 2&#125;</div></pre></td></tr></table></figure></p>
<p>其实我认为对于浅拷贝解释的更清楚的是浅拷贝只<strong>复制一层对象的属性</strong>，尤其是这句话适合理解那些看起来像是深拷贝但是实际上是浅拷贝的操作，例如之前我说的使用扩展运算对数组进行拷贝，或者Array的<code>slice</code>和<code>concat</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 扩展运算</div><div class="line">let arr1 = [1, &#123;a: 1&#125;]</div><div class="line">let arr2 = [...arr1]</div><div class="line"></div><div class="line">arr2.push(3)</div><div class="line">arr2[1].a = 2</div><div class="line"></div><div class="line">// arr1 [1, &#123;a: 2&#125;]</div><div class="line">// arr2 [1, &#123;a: 2&#125;, 3]</div></pre></td></tr></table></figure></p>
<p>可以看出，通过扩展运算对数组进行拷贝后，修改新数组內对基本类型变量的操作不会对原数组产生影响，但是如果对其中的引用类型变量内部的值进行了修改，则会对原数组产生同样对效果，这是因为虽然扩展运算是并不是将原数组的引用进行了拷贝，但是对其内部的引用类型变量仍然是拷贝了他们的引用，没有进行递归拷贝创建一个全新的值相等的数组，同理对于对象来说也是如此。</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>与浅拷贝不同，深拷贝将原引用类型对象內的所有属性通过递归复制的方式拷贝到新对象上，因此新对象中的引用类型元素和原对象中的引用类型元素指向的都是不同的地址，因此不会互相干扰。不过在通常的场景中，因为对于层级较多的对象深复制的性能开销比较大，因此浅拷贝更为常用。</p>
<p>在js中，没有内置的深拷贝方法，可以通过<code>JSON</code>的相关方法进行不完整的深拷贝，即通过<code>JSON.parse(JSON.stringify(obj))</code>的方式，不过这种方式仅限于对<code>Object</code>类型，对于<code>Array</code>，<code>Function</code>等其他引用类型不适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;a:1, b:2&#125;</div><div class="line">var obj2 = JSON.parse(JSON.stringify(obj1)) // obj2 &#123;a:1, b:2&#125;</div><div class="line"></div><div class="line">obj2.a = 3</div><div class="line"></div><div class="line">//obj1 &#123;a:1, b:2&#125;</div><div class="line">//obj2 &#123;a:3, b:2&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，浅拷贝只拷贝了属性的第一层属性，而深拷贝递归拷贝了所有的属性，在js中并没有内置的方法进行深拷贝，<code>slice</code>和<code>concat</code>以及通过扩展运算进行数组的拷贝从本质上来说都是像深拷贝的浅拷贝操作，而通过<code>JSON</code>的相关方法进行深拷贝只是不完整的深拷贝，因此在实践中如果真的遇到万不得已需要深拷贝的操作，还是只能针对需求去自己写一下，(感觉什么都没说。。。)。最后贴两张从知乎上面看到对于这个问题对图解，我感觉很有帮助，链接我也会贴在最后，希望大家有时间可以去原答案上给答主点赞。</p>
<p>浅拷贝</p>
<p>深拷贝</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.zhihu.com/people/yang-shuo-92-53/activities" target="_blank" rel="external">知乎 javascript中的深拷贝和浅拷贝？</a></p>
<p><a href="https://segmentfault.com/a/1190000008637489" target="_blank" rel="external">segmentfault JavaScript中的浅拷贝和深拷贝</a></p>
<p><a href="https://github.com/wengjq/Blog/issues/3" target="_blank" rel="external">github javaScript中浅拷贝和深拷贝的实现</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/19/学习es6——Promise对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="victorxpz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/chai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XPZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/19/学习es6——Promise对象/" itemprop="url">
                  学习es6——Promise对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-19T22:04:11+08:00">
                2017-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在es6中引入了<code>Promise</code>对象处理异步请求，其包含三种状态:Pending, Fulfilled和Rejected，分别代表了初始状态、完成和失败。Promise对象状态的改变只有两种情况:Pending -&gt; Fulfilled或者Pending -&gt; Rejected。当状态变为Fulfilled或Rejected时，Promise对象就可以被称作Resolved，即已定型的。当状态改变之后，Promise对象会一直保持该状态和结果，当回调函数进行监听时即可取得最终结果。本文主要讲述了Promise的基本概念、<code>then</code>方法等。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>构造Promise对象实例的语法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Promise(function (resolve, reject) &#123;&#125;)</div></pre></td></tr></table></figure></p>
<p>由此可见Promise对象其实是一个构造函数，它只接受一个函数参数，这里将其成为<code>executor</code>，<code>executor</code>函数的参数又分别是两个函数，即<code>resolve</code>和<code>reject</code>。<code>resolve</code>的作用是将状态从Pending变为Fulfilled，并将结果发送出去；而<code>reject</code>的作用则是将状态从Pending变为Rejected，并将失败的信息(通常为报错信息)发送出去。另外需要注意的时，在构建Promise实例时，会同步执行executor函数中的语句。<br>对于生成的promise实例，可以用<code>then</code>方法指定回调函数对返回结果进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let p = new Promise(function (resolve, reject) &#123;&#125;)</div><div class="line">p.then(function (value) &#123;</div><div class="line"></div><div class="line">  &#125;, function (error) &#123;</div><div class="line"></div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p><code>then</code>方法接受两个参数，分别为对于完成状态和失败状态的回调函数，回调函数的参数数量与<code>resolve</code>和<code>reject</code>函数传递出来的异步操作的结果有关，其中第二个函数，即失败状态的回调函数为可选参数，一般不选，使用后文提及的<code>catch</code>方法对失败状态进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let p = new Promise((resolve, reject) =&gt; &#123;</div><div class="line">  console.log(&apos;Promise&apos;)</div><div class="line">  resolve()</div><div class="line">&#125;)</div><div class="line">p.then(() =&gt; &#123;</div><div class="line">  console.log(&apos;resolve&apos;)</div><div class="line">&#125;)</div><div class="line">console.log(&apos;hi&apos;)</div></pre></td></tr></table></figure></p>
<p>执行上述代码后，在控制台将会先后输出”Promise”,”hi”和”resolve”。这是因为在执行Promise构造函数时，<code>executor</code>函数将会同步执行，而因为<code>then</code>方法中的回调函数将在当前这轮任务的最后执行，所以会先打印出”hi”，之后才是”resolve”。</p>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>之前已经提到过，Promise实例使用<code>then</code>方法对状态结果进行回调处理。而需要注意的是，<code>then</code>方法的返回值是一个新的<code>Promise</code>实例(不是之前的)，也就是说<code>then</code>方法可以进行链式的写法，即<code>p.then().then()</code>。这种写法在需要通过一组异步操作得到结果时比较有效，即第一个<code>then</code>返回一个新的包含异步操作的Promise实例，之后的<code>then</code>方法需要对这个Promise实例的最终状态进行监听并添加回调函数。</p>
<h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><code>catch</code>方法是<code>then(null, rejection)</code>的别名，用于指定发生错误时的回调函数，写法为<code>p.catch(function (error) {})</code>。Promise对象的错误具有”冒泡”性质，即错误会一直向后传递直到被捕获，所以无论在调用<code>catch</code>方法前有多少Promise对象进行报错，都会被最后调用的<code>catch</code>方法捕获。结合上面讲过的<code>then</code>函数，为Promise实例添加回调函数通常可以写成如下形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let p = new Promise(function (resolve, reject) &#123;&#125;)</div><div class="line">p.then( function (value) =&gt; &#123;</div><div class="line">    // 成功时回调</div><div class="line">  &#125;)</div><div class="line">  .catch( function (error) =&gt; &#123;</div><div class="line">    // 错误时回调</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p>注意，如果在<code>executor</code>函数中已经使用<code>resolve</code>函数改变了状态，那么之后在同一个Promise对象內抛出的错误则不会被执行，因为Promise对象的状态一旦改变，就会永久保持住，不会再次更改。</p>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><code>Promise.resolve</code>方法将已有对象转换为Promise对象，接收一个参数，参数的类型包括以下几种情况。</p>
<ul>
<li><p>Promise对象</p>
<p>这种情况下<code>Promise.resolve</code>方法将会原模原样的将对象返回。</p>
</li>
<li><p>一个thenable对象</p>
<p>thenable对象是指本身具有<code>then</code>方法的对象，对于这种类型的参数，<code>Promise.resolve</code>方法将会将他转变成Promise对象并立即执行该对象之前的<code>then</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let thenable = &#123;</div><div class="line">  then: (resolve, reject) =&gt; &#123;</div><div class="line">    resolve(&quot;victor&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let p = Promise.resovle(thenable)</div><div class="line">p.then((value) =&gt; &#123;</div><div class="line">  console.log(value)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 控制台输出&quot;victor&quot;</div></pre></td></tr></table></figure>
<p>当时我也对这个转化理解了一段时间，后来在网上查看资料，发现这就是一个语法糖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 声明thenable</div><div class="line"></div><div class="line">let p = Promise.resolve(thenable)</div><div class="line"></div><div class="line">// 等价于</div><div class="line"></div><div class="line">let p = new Promise((resolve, reject) =&gt; &#123;</div><div class="line">  thenable.then(resolve, reject)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>我觉得可以理解成将thenable中的then函数作为Promise构造函数的<code>executor</code>函数参数并传入，从而生成心的Promise实例。</p>
</li>
<li><p>一个普通对象或者其他类型的变量</p>
<p>这种情况下<code>Promise.resolve</code>方法将会返回一个完成状态(Fulfilled)的Promise实例，<code>Promise.resolve</code>方法的参数将会传递给回调函数。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Promise对象在处理异步编程时具有很大的作用，最为明显的就是在网络请求方面，能够很好的安排对返回结果的处理逻辑。因为最近在项目中使用到，所以查阅了一些相关资料，这篇文章也只是讲了有关Promise对象的部分知识，我也将我认为有价值的阅读资料链接放在下面，希望也能够有小伙伴从中收益吧～今天就到这里啦～溜了溜了～</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰es6入门</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN</a></p>
<p><a href="https://segmentfault.com/q/1010000005330351" target="_blank" rel="external">Segmentfault关于Promise.resolve方法的讨论</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/13/Flex布局学习心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="victorxpz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/chai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XPZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/13/Flex布局学习心得/" itemprop="url">
                  Flex布局学习心得
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-13T09:39:47+08:00">
                2017-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近看了一些介绍Flex布局的文章，学到了不少东西，在这里简要的汇总一下。</p>
<ul>
<li><p>Flex布局的盒模型和术语<br>Flex布局的构成元素分为两种：<code>flex container</code>和<code>flex item</code>。为元素样式<code>display</code>设置<code>flex</code>或<code>inline-flex</code>即可使其成为一个<strong>弹性容器</strong>(flex container)。弹性布局容器内部的元素则被称为<strong>弹性项目</strong>(flex item)，而在容器内部的文字也会成为flex item，只不过是<strong>匿名</strong>的flex item，<strong>匿名</strong> 是指无法在css文件中单独为他们指定特殊的样式，只能继承父元素的样式。<br>!(图片)[<a href="https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_120x44dp.png" target="_blank" rel="external">https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_120x44dp.png</a>]<br>Flex布局主要的术语有以下几种：<br>主轴(main axis)、主轴方向(main dimension)：一个弹性容器的主轴是指其弹性元素排列的方向，主轴沿着主轴方向眼神。<br>主轴起点(main-start)、主轴终点(main-end)：弹性元素在父容器内部从按照从主轴起点到主轴终点的顺序排列。<br>主轴尺寸(main size)、主轴尺寸属性(main size property)：弹性元素在主轴方向上的尺寸(宽或高)是它的主轴尺寸，它在主轴方向上的尺寸属性(宽或高)是它的主轴尺寸属性。<br>侧轴(cross axis)、侧轴方向(cross dimension)：和主轴垂直的轴即为侧轴，侧轴沿着侧轴方向延伸。<br>侧轴起点(cross-start)、侧轴终点(cross-end)：<code>flex line</code>由弹性元素在主轴方向上填充，并从侧轴起点开始排列，到侧轴终点结束。<br>侧轴尺寸(cross size)、侧轴尺寸属性(cross size property)：弹性元素在侧轴方向上的尺寸(宽或高)是它的侧轴尺寸，它在侧轴方向上的尺寸属性(宽或高)是它的侧轴尺寸属性。</p>
</li>
<li><p>顺序和方向<br>弹性元素在父容器中的排列顺序和方向可以由以下几个属性置顶。</p>
<ul>
<li>flex-direction<br>通过在弹性容器上设置flex-direction的值可以指定弹性元素的排列方向，也就是置顶了主轴的方向。它有以下四种可能的取值：<ul>
<li>row(默认值)<br>弹性元素的排列方向与当前<code>writing mode</code>的行内布局轴方向相同。</li>
<li>row-reverse<br>与<code>row</code>相同，不过主轴起点和主轴终点调换位置。</li>
<li>column<br>弹性元素的排列方向与当前<code>writing mode</code>的块级布局轴方向相同。</li>
<li>column-reverse<br>与<code>column</code>相同，不过主轴起点和主轴终点调换位置。</li>
</ul>
</li>
<li>flex-wrap<br>通过在弹性容器上设置<code>flex-wrap</code>的值可以决定该弹性容器是否允许在主轴元素超出容器尺寸时换行(列)。有以下三种可能的取值：<ul>
<li>nowrap(默认值)<br>弹性容器不允许换行(列)，即它只有一行(列)。</li>
<li>wrap<br>弹性容器允许换行(列)，即它可能是一个多行(列)容器。</li>
<li>wrap-reverse<br>与<code>wrap</code>相同，不过侧轴起点和侧轴终点调换位置。</li>
</ul>
</li>
<li>flex-flow<br><code>flex-flow</code>是由<code>flex-wrap</code>和<code>flex-direction</code>合并的简写，它的取值是<code>flex-direction|flex-wrap</code>，默认值为<code>row|nowrap</code>。</li>
<li>order<br>弹性元素在默认情况下是按照在文档中出现的顺序依次排列，不过可以通过为其<code>order</code>样式设置值改变其出现的顺序，容器将会根据<code>order</code>的值从小到大排列弹性元素，即越小顺序越靠前，<code>order</code>的默认值为0，可以取负值。需要注意的是这样仅仅是<strong>改变了元素在浏览器中显示的顺序，并不会改变其在文档中的顺序</strong>。</li>
</ul>
</li>
<li>布局<br>弹性元素的具体布局可以由一下几个属性设置<ul>
<li>justify-content<br>为弹性容器设置<code>justify-content</code>可以指定弹性元素在主轴上的排列位置，有以下五种可能的取值<ul>
<li>flex-start(默认值)<br>每一条<code>flex line</code>上的弹性元素将会向主轴起点靠拢</li>
<li>flex-end<br>每一条<code>flex line</code>上的弹性元素将会向主轴终点靠拢</li>
<li>center<br>每一条<code>flex line</code>上的弹性元素将会向主轴的中部靠拢</li>
<li>space-between<br>每一条<code>flex line</code>上的弹性元素会均匀分布，第一个元素在主轴起点位置，最后一个元素在主轴终点位置</li>
<li>space-around<br>与<code>space-between</code>类似，不过第一个和最后一个元素会分别与主轴的起(终)点空两个元素间隔1/2的距离。</li>
</ul>
</li>
<li>align-items<br><code>justify-content</code>可以设置弹性元素在主轴方向上的空间分布，相应的，<code>align-items</code>可以设置元素在侧轴方向上的空间分布，这个属性也有以下五种可能的取值<ul>
<li>flex-start<br>弹性元素在侧轴起点边的外边距紧靠侧轴起点所在的边</li>
<li>flex-end<br>弹性元素在侧轴终点边的外边距紧靠侧轴终点所在的边</li>
<li>center<br>弹性元素在侧轴居中</li>
<li>baseline<br>弹性元素根据基线对齐</li>
<li>stretch(默认值)<br>弹性元素在侧轴方向拉伸到与容器一样的尺寸</li>
</ul>
</li>
<li>align-self<br><code>align-items</code>作用于弹性容器，而<code>align-self</code>则作用于弹性元素，它的含义与<code>align-items</code>相同，并且取值会覆盖<code>align-items</code>的值。相比于<code>align-items</code>，<code>align-self</code>多了一个可选取值<code>auto</code>，这个值的含义就是继承容器中<code>align-items</code>的值，如果容器没有设置这个属性，则为<code>stretch</code>。</li>
<li>align-content<br>之前曾经提到过，根据<code>flex-wrap</code>的取值和弹性元素的数量，容器可能会有多条<code>flex line</code>。而就像<code>justify-content</code>和<code>align-items</code>可以为每一条<code>flex line</code>上的弹性元素分配他们在这条线上的空间一样，也有属性可以为多条<code>flex line</code>分配他们在容器中的空间，这个属性就是<code>align-content</code>。由于每一条<code>flex line</code>在主轴方向已经占据了全部空间，因此这个属性的作用就是为每条<code>flex line</code>在侧轴方向分配空间，有以下几种可能的取值：<ul>
<li>flex-start<br>伸缩线向侧轴起点靠拢</li>
<li>flex-end<br>伸缩线向侧轴终点靠拢</li>
<li>center<br>伸缩线向侧轴中部靠拢</li>
<li>space-between<br>伸缩线均匀分布，第一条和最后一条伸缩线紧靠侧轴起点和终点</li>
<li>space-around<br>伸缩线均匀分布，第一条和最后一条伸缩线与侧轴起点和终点留出两条伸缩线间1/2的距离</li>
<li>stretch(默认)<br>伸缩线在侧轴方向拉伸至占据所有侧轴方向的空间</li>
</ul>
</li>
</ul>
</li>
<li>弹性<br>之前讲的均是flex的布局方面的技巧，而其之所以被称为<strong>弹性</strong>布局，当然尤其在伸缩性上的特殊之处，下面就介绍一下弹性布局在伸缩性上的特殊属性，这些属性的作用对象均为<strong>弹性元素</strong>。<ul>
<li>flex-grow<br><code>flex-grow</code>定义了弹性元素的伸展能力，当主轴方向出现剩余空间时，伸展性越强的元素所占据的空间越多，其取值为一个整数，默认值为0。</li>
<li>flex-shrink<br><code>flex-shrink</code>定义了弹性元素的收缩能力，当主轴方向空间不足时，伸缩性越强的元素所收缩的空间越多，其取值也为一个整数，默认值为1。需要注意的是，当取负值时该属性也有效，与绝对值相同，即<code>flex-shrink: -5</code>与<code>flex-shrink: 5</code>拥有相同的效果。</li>
<li>flex-basis<br><code>flex-basis</code>定义了弹性元素的伸缩基准值，该属性的取值会覆盖元素本身的主轴尺寸。除了常规的尺寸取值之外，还可以为这个属性设置<code>auto</code>值，在这个取值作用下，该元素的伸缩基准值就等于它的主轴尺寸。默认值为<code>auto</code>。</li>
<li>flex<br><code>flex</code>属性是以上三个属性的合并值，即其取值为<code>flex-grow|flex-shrink|flex-basis</code>，后两个值可选。当<code>flex</code>属性的值为<code>auto</code>时，这三个属性的值分别为<code>0 0 auto</code>。<code>flex</code>属性的默认值为<code>1 0 auto</code>。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/啃食红宝石——垃圾收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="victorxpz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/chai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XPZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/05/啃食红宝石——垃圾收集/" itemprop="url">
                  啃食红宝石——垃圾收集
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T20:56:54+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JavaScript中，垃圾收集主要有两种方式，标记删除和计数删除。</p>
<ul>
<li><p>标记删除<br>在垃圾收集器运行时，首先它会给所有变量打上标记，之后为执行环境中的变量即环境变量引用的变量去除标记，这样使得剩余拥有标记的变量和之后再被打上标记的变量被视为准备删除的变量。最后垃圾收集器会消除那些有标记的变量，完成清理内存的工作。例子如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var outername = getName();</div><div class="line">function getName()&#123;</div><div class="line">  var innername = &quot;victor&quot;;</div><div class="line">  return innername;</div><div class="line">&#125;</div><div class="line">alert(outername);</div></pre></td></tr></table></figure>
<p>当变量<code>outername</code>的声明语句执行时，垃圾收集器会为<code>outername</code>,<code>getName</code>,<code>innername</code>打上标记，若此时执行到函数内部，则执行环境为其局部环境，所以垃圾收集器会去除这三个变量的标记，当<code>return</code>语句执行完成之后，执行环境由函数<code>getName</code>的局部环境变为全局环境，因此垃圾收集器再次运行时依旧会为三个变量都打上标记，但是只会去除<code>outername</code>的标记，因此最后<code>getName</code>和<code>innername</code>会被其销毁。<br>这种删除策略是现在浏览器普遍采用的策略。</p>
</li>
<li><p>引用计数<br><strong>引用计数</strong> 是一种不太常见的垃圾收集策略。引用计数的意思是指记录每个变量被引用的次数，当一个引用类型值被赋予一个变量时，引用次数加1，当一个值为该引用类型值的变量被赋予了另外一个值，则引用次数减1，最终当引用次数为0时，则销毁该变量。例子如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123;</div><div class="line">  name:　&quot;victor&quot;;</div><div class="line">&#125;;</div><div class="line">person2 = person1;</div><div class="line">person1 = null;</div><div class="line">person2 = null;</div></pre></td></tr></table></figure>
<p>当语句<code>person2 = person1</code>执行完成之后，他们两个引用的对象<code>{name: &quot;victor&quot;}</code>的引用次数为2，而当语句<code>person1 = null</code>执行完成之后，<code>person1</code>就切除了与引用值之间的联系，因此引用值<code>{name:&quot;victor&quot;}</code>的引用次数变为1，而最后因为<code>person2</code>也解除了和引用值之间的联系，因此引用值最后的引用次数为0，如果这段代码是在采用了引用计数策略的环境中执行的，该引用值就会在下次垃圾收集器运行时被销毁。<br>不过这种策略现在已经很少见，由其带来的循环引用变量无法销毁的问题也不再详述，有兴趣的胖友可以看书0.0</p>
</li>
</ul>
<p>对于我们来说，JS引擎具体采用的哪种垃圾回收策略其实并不是我们所能改变的，但是我们应该尽可能的占用少量的内存以保证浏览器的崩溃。优化内存的最佳方式就是<strong>接触引用</strong>，即一旦确保某个变量不会再次使用，就将其值设为<code>null</code>。这一方式主要针对于全局环境中的变量，因为处于函数的局部环境中的变量会在函数执行完成之后自动解除引用。接触值引用的意义在于让其脱离执行环境，以便下次垃圾收集器运行时将其回收。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/04/啃食红宝书——作用域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="victorxpz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/chai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XPZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/04/啃食红宝书——作用域/" itemprop="url">
                  啃食红宝书——作用域
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-04T15:10:25+08:00">
                2017-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>失踪人口回归= =这两周一直在外面验收项目，这两天终于有时间看书，今天写一下自己对于执行环境作用域的理解。<br>在JavaScript中，<strong>执行环境(环境)</strong>定义了函数或变量有权访问的其他数据，每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的变量和函数都保存在这个变量对象中。值得注意的是，我们编写的程序是无法直接访问这个变量对象的，只有解析器在处理数据时会使用它。<br>最外层的执行环境称为全局执行环境，根据代码所在的宿主环境不同，全局环境也有所不同，最常见的全局执行环境就是<code>window</code>(浏览器)。执行环境中的代码执行完成之后，该环境被销毁，其拥有的变量和函数也随之销毁。<br>每个函数都有自己的执行环境，而对于函数来说，它的执行环境所关联的变量对象称为<strong>活动对象</strong>。活动对象在一开始只包含<code>arguments</code>对象。<br>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链的作用在于保证了对于环境栈中执行环境的变量和函数的访问的有序性。当进入函数时，作用域链中的变量对象排序为<strong>从内到外</strong>，如下: (该函数的)活动对象=&gt;(包含函数)的活动对象=&gt;…=&gt;全局环境的变量对象。在搜索标识符时，会沿着作用域链一层层向上搜索，找到目标标识符后就停止搜索，如果在全局环境中依然没有找到目标标识符，通常会报错。举例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var name = &quot;Victor&quot;;</div><div class="line">function changeName(newName)&#123;</div><div class="line">  name = newName;</div><div class="line">&#125;</div><div class="line">changeName(&quot;Jessica&quot;);</div></pre></td></tr></table></figure></p>
<p>当调用了<code>changeName</code>函数时，执行流进入<code>changeName</code>函数内部，此时作用域链如下:<code>changeName</code>的活动对象=&gt;全局环境的变量对象。此时查找变量<code>name</code>时，会沿着作用域链搜索，虽然在函数内部没有定义<code>name</code>变量，但是依然可以在全局变量中找到<code>name</code>变量并执行代码。<br>在作用域链中搜索变量或函数名的操作是单向且不可逆的，内部环境可以沿着作用域链访问外部环境，但是外部环境不能访问内部环境。比如<code>changeName</code>的环境能够访问全局环境中的<code>name</code>，而全局变量无法访问<code>changeName</code>环境中的<code>newName</code>。</p>
<ul>
<li>延长作用域链<br>执行环境通常分为两类：全局环境和局部环境。不过有的语句会在作用域链的前端临时添加一个变量对象，从而延长作用域链，该变量对象在语句执行完毕后就会从作用域链中移除。在两种情况下会发生这种情况:<ul>
<li>try-catch语句中的catch块</li>
<li>with语句<br>catch语句会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。而with语句会将接收的对象添加到作用域链的顶端。因此这两种语句会延长作用域链。</li>
</ul>
</li>
<li><p>没有块级作用域<br>  JavaScript中没有块级作用域的概念。最简明的例子如下:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(false)&#123;</div><div class="line">  var name = &quot;Jessica&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  因为JavaScript中没有块级作用域，因此上述代码执行时并不会报变量没有声明的例子，原因就是在<code>if</code>代码块中对于<code>name</code>变量的声明会被提升到外部，上述代码等价于下面的代码:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var name;</div><div class="line">if(false)&#123;</div><div class="line">  name = &quot;Jessica&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  也因此，在执行完<code>if</code>代码块之后，<code>name</code>变量并不会被销毁，只有当它所在的全局环境销毁时它才会销毁。<br>  由于这个特性，通过<code>var</code>声明的变量会被自动添加到最近的执行环境中，即全局环境或者局部(函数)环境。如果没有用<code>var</code>声明，则会添加到全局环境中。<br>  另外一点指的注意的是，如前文所述，搜索标识符时会沿着作用域链进行搜索，一旦找到目标标识符即停止搜索，因此如果在局部环境和全局环境中有两个相同的标识符，在搜索时局部环境内的标识符会<strong>覆盖</strong>全局环境的标识符。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var name = &quot;victor&quot;;</div><div class="line">function changeName()&#123;</div><div class="line">  var name = &quot;jessica&quot;;</div><div class="line">  console.log(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  执行如上代码会在命令行中输出<code>jessica</code>，因为搜索标识符<code>name</code>时，在局部环境中已经搜索到了目标标识符，就不会在沿着作用域链搜索全部环境了。当作用域链中含有多个局部环境中时同理，一旦搜索到目标标识符就不会再搜索外部的执行环境。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/14/啃食红宝书——JSON-第20章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="victorxpz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/chai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XPZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/14/啃食红宝书——JSON-第20章/" itemprop="url">
                  啃食红宝书——JSON(第20章)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-14T21:36:53+08:00">
                2017-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开始认真刷红宝书了，会把每一章自己学到的稍微记录一下，希望也能帮助自己更好的理解书中的内容。很酷。<br>JSON是当前非常流行的一种数据交换格式，就我个人的体验而言，使用JSON作为前后端的数据交换格式非常的方便，本文就简要介绍一下JSON的特殊之处以及在JavaScript中如何处理这种数据格式。<br>首先，虽然JSON是JavaScript的一种子集，但是与JS中对象的表示方式不同，JSON要求属性名称必须带有<strong>双括号</strong>引用，不能是单括号也不能没有括号。例如以下这种数据结构在JS中是合法的，但是在JSON中是不被允许的:</p>
<pre><code>{
  name: &quot;jessica&quot;,
  age: 18
}
</code></pre><p>在JSON中需要将属性名称加上双括号，即:</p>
<pre><code>{
  &quot;name&quot;: &quot;jessica&quot;,
  &quot;age&quot;: 18
}
</code></pre><p>而这两种表示方法在JS中都是合法的。<br>其次，JavaScript也有专门的函数用来解析与序列化JSON。<code>stringify()</code>用来将JavaScript对象序列化成JSON字符串，<code>parse()</code>用来将JSON字符串解析为原声JavaScript值。</p>
<ul>
<li><p><code>JSON.stringify()</code></p>
<pre><code>var person = {
    name: &quot;jessica&quot;,
    age: 18
}
var personJSON = JSON.stringify(person);
</code></pre><p>执行以上代码之后，<code>personJSON</code>的值变为<code>{&quot;name&quot;:&quot;jessica&quot;,&quot;age&quot;:18}</code>，即<code>person</code>对象被<code>JSON.stringify()</code>序列化成了<code>personJSON</code>JSON字符串.<br>上述用法是最常用的也是最基本的JSON序列化方法。撤了要被序列化的JS对象之外，<code>stringify()</code>还可以接收另外两个参数进行不同的序列化，这两个参数用于指定以不同的方式序列化JavaScript对象。下面就详细说一下这两个参数。</p>
<blockquote>
<p>第一个参数是个过滤器(replacer)，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在JSON字符串中保留缩进。</p>
</blockquote>
<p>对于过滤器参数，如果其是一个数组，则序列化之后的JSON字符串将只含有在过滤器数组中列出的属性。还是以<code>person</code>对象为例进行序列化:</p>
<pre><code>JSON.stringify(person,[&quot;name&quot;]);
</code></pre><p>上面一行代码中为<code>stringify()</code>函数传入了一个数组作为过滤器参数，数组中只有一个字符串<code>name</code>，则序列化的JSON字符串只包含<code>name</code>属性而不包含<code>age</code>属性，序列化后JSON字符串如下:</p>
<pre><code>{&quot;name&quot;:&quot;jessica&quot;}
</code></pre><p>除了数组，过滤参数器还可以是一个函数的形式。传入的函数接收两个参数，属性名和属性值，即key和value。根据这两个参数可以决定序列化后的JSON字符串的值。</p>
<blockquote>
<p>为了改变序列化对象的结果，函数返回的值就是相应键的值，不过要注意，如果函数返回了undefined，那么相应的属性会被忽略。</p>
</blockquote>
<p>依然以<code>person</code>对象为例:</p>
<pre><code>JSON.stringify(person,function(key,value){
    switch(key){
        case &quot;name&quot;:
            return undefined;
        case &quot;age&quot;:
            return value+&quot;岁&quot;;
        default:
            return value;
    }
});
</code></pre><p>上述代码中，过滤器函数为<code>name</code>属性返回<code>undefined</code>，则在序列化后的JSON中将不会含有<code>name</code>属性；而过滤器函数为<code>age</code>属性返回了由年龄和岁拼接成的字符串，所以以上代码会将<code>person</code>对象序列化成<code>{&quot;age&quot;:&quot;18岁&quot;}</code>。<br><code>JSON.stringify()</code>的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数。例如<code>JSON.stringify(person,null,4)</code>可以在每个级别缩进四个空格。而在这里需要注意的是，<strong>只要传入了有效的控制缩进的参数值，序列化后的JSON字符串就会包含换行符。</strong> 最大的缩进空格数为10。<br>如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用作缩进字符(不再使用空格)，即空格的缩进位置被缩进字符所替代，锁紧字符串最长也不能超过10个字符长。<br>在序列化过程中，还有一个很重要的方法叫做<code>toJSON()</code>方法。当<code>JSON.stringify()</code>不能满足自定义序列化的需求时，可以为对象定义<code>toJSON()</code>方法，返回其自身的JSON数据格式。原生Date对象就有一个toJSON()方法。以<code>person</code>对象为例</p>
<pre><code>{
  name: &quot;jessica&quot;,
  age: 18,
  toJSON: function(){
    return this.name;
  }
}
</code></pre><p>如果为<code>person</code>对象定义了一个如上的<code>toJSON</code>方法，那么执行<code>JSON.stringify(person)</code>后对象将会序列化成<code>jessica</code>。<strong>注意此时序列化后的字符串只保留了值而不保留属性名称，这是因为<code>toJSON</code>方法中只返回了属性的值。</strong><br><strong>!!!对象的序列化顺序</strong>：</p>
<blockquote>
<p>1.如果存在<code>toJSON()</code>方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。<br>2.如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第1步返回的值。<br>3.对第2步返回的每个值进行相应的序列化。<br>4.如果提供了第三个餐宿，执行相应的格式化。</p>
</blockquote>
</li>
<li><p><code>JSON.parse()</code><br> <code>JSON.parse()</code>将JSON字符串解析为JS对象，可以理解为序列化的逆过程。除了JSON字符串外，这个方法也可以接收另外一个参数，该参数为一个函数，接收一个键和一个值，并且需要返回一个值，为了与<code>stringify()</code>中的replacer区别，这个函数被称为还原函数(receiver)。当解析后的对象中含有<code>Date</code>类型的实例时，经常用到这个函数，因为在序列化时会调用<code>Date</code>实例内部的<code>toJSON()</code>方法，所以在解析时需要重新变换一下。</p>
<pre><code>var time = {
    newDate: new Date(2017, 5, 14)
}
var timeJSON = JSON.stringify(time);
var time1 = JSON.parse(time);
var time2 = JSON.parse(time,function(key,value){
    if(key===&quot;newDate&quot;){
      return new Date(value);
    }else {
      return value;
    }
});
</code></pre><p><code>time1</code>和<code>time2</code>分别是未使用和使用还原函数之后解析出来的JS对象，我在下面这个表格中列出了这两个对象和序列化之前的<code>time</code>对象中的<code>newDate</code>属性的值的不同，可以看出<code>time2</code>中的<code>newDate</code>属性才是我们想要得到的。<code>time1.newDate</code>的值为<code>&quot;2017-06-13T16:00:00.000Z&quot;</code>，而<code>time2.newDate</code>的值为<code>Wed Jun 14 2017 00:00:00 GMT+0800 (中国标准时间)</code>。</p>
<p>\ | time1 | time2 | time<br>—-|——|—- |—-<br>typeof object.newDate| string  | object | object<br>object.newDate typeof Date | false  | true | true<br>值 | “2017-06-13T16:00:00.000Z”  | Wed Jun 14 2017 00:00:00 GMT+0800 (中国标准时间) | Wed Jun 14 2017 00:00:00 GMT+0800 (中国标准时间)</p>
</li>
</ul>
<p>以上就是我学到的红宝书中关于JSON方面的知识，会继续努力学习其他章节的！很酷，溜了！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/29/jQuery中为动态加载的DOM元素绑定事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="victorxpz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/chai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XPZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/29/jQuery中为动态加载的DOM元素绑定事件/" itemprop="url">
                  jQuery中为动态加载的DOM元素绑定事件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-29T10:52:44+08:00">
                2017-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近终于有项目给自己的前端练手，因为是第一个项目，所以难免遇到各种各样的问题，不过踩坑也是很重要的一部分。今天说的就是一个小坑。很酷，不说闲话，步入正题。<br>因为在项目中经常需要通过ajax动态填充表格，而我在为表格中的元素绑定事件时理所当然的像往常一样，直接去寻找DOM元素然后为其添加<code>on()</code>函数，然而在页面加载后发现为表格中元素绑定的事件并没有产生应有的效果，后来经过查看jQuery官网的api文档发现了错误的原因，原文如下：</p>
<blockquote>
<p>Event handlers are bound only to the currently selected elements; they must exist at the time your code makes the call to .on().</p>
</blockquote>
<p>这句话的大意就是说只能为<strong>当前存在</strong>的DOM元素绑定事件，即在调用<code>on()</code>函数时当前元素必须存在于DOM树中。而对于如何为动态加载或者稍后才加载的元素绑定事件，文档中也给出了详细的方法：</p>
<blockquote>
<p>Alternatively, use delegated events to attach event handlers.</p>
</blockquote>
<p>即使用<strong>事件代理</strong>的方法为元素绑定事件，事件代理在jQuery中最开始通过<code>delegate()</code>方法实现，在<code>on()</code>函数出现后被取代。如果不了解事件代理的话可以查一下资料(其实当时我也不懂= =)。关于事件代理的优点，文档中也说的很清楚：</p>
<blockquote>
<p>Delegated events have the advantage that they can process events from descendant elements that are added to the document at a later time.</p>
</blockquote>
<p>通过事件代理，可以为稍后添加的<strong>后代元素</strong>传递事件。也就是说，只要能确保被绑定的元素一定存在，就可以通过事件代理的做法为其绑定事件，这样做的好处就是不用考虑代码的顺序，只要考虑元素是否会存在即可。<br>我的理论理解说的差不多了，下面来具体实现一下吧。<br>html:</p>
<pre><code>&lt;body&gt;
  &lt;button&gt;按钮&lt;/button&gt;
&lt;/body&gt;
</code></pre><p>js:</p>
<pre><code>&lt;script&gt;
  $(function(){
    //绑定事件
    $(&quot;button&quot;).on(&quot;click&quot;,function(){
      alert($(this).text());
    });
    //动态添加按钮
    function addButton(){
      var newButton = &quot;&lt;button&gt;新按钮&lt;/button&gt;&quot;;
      $(&quot;body&quot;).append(newButton);
    }
    addButton();
  });
&lt;/script&gt;
</code></pre><p>按照上面的代码，点击页面中新添加的按钮将不会有效果，因为在绑定事件时DOM树中还没有新按钮这个<code>button</code>元素。如果想绑定成功的话有两种方法：第一种就是在<code>on()</code>函数调用前先调用<code>addButton()</code>函数，将<code>button</code>元素先添加到DOM树中，这种方法虽然看起来不麻烦，但是在实际的项目工程中因为通常是通过ajax动态加载元素，这种方法就显得很不实用，因此通常使用的就是第二种方法，即事件代理。事件代理的代码实现也很简单，即将绑定事件修改为如下代码：</p>
<pre><code>$(&quot;body&quot;).on(&quot;click&quot;,&quot;button&quot;,function(){
  alert($(this).text());
});
</code></pre><p>注意到在<code>on()</code>函数的调用中，我们多添加了一个参数<code>button</code>，这个参数在官方文档中被称为<code>selector</code>。一旦这个参数在<code>on()</code>的调用中的值具有实际意义，则对于该元素的绑定事件就会被当做事件代理，这一点在官方文档中也有说明：</p>
<blockquote>
<p>When a selector is provided, the event handler is referred to as delegated. The handler is not called when the event occurs directly on the bound element, but only for descendants (inner elements) that match the selector.</p>
</blockquote>
<p>另外需要注意的是，通过<code>on()</code>函数实现事件调用时，<code>selector</code>参数是需要绑定的元素，而调用<code>on()</code>函数的元素应是它的<strong>祖先元素</strong>（这里应该注意，虽然没有要求是父元素，但为了性能考虑，对祖先元素在DOM树中的定位应该越精确越好，所以通常定位到<strong>父元素</strong>）。也就是说像下面的代码是<strong>没有效果</strong>的：</p>
<pre><code>$(&quot;button&quot;).on(&quot;click&quot;,&quot;button&quot;,function(){
  alert($(this).text());
});
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/06/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="victorxpz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/chai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XPZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/06/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-06T19:50:20+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/chai.jpg"
               alt="victorxpz" />
          <p class="site-author-name" itemprop="name">victorxpz</p>
           
              <p class="site-description motion-element" itemprop="description">想做个盖世英雄</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/smilebuz" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">victorxpz</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
